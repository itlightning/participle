// Code generated by participle parser generator. DO NOT EDIT.
// source: github.com/alecthomas/participle/v2/testgen.Combined
// If code breaks after changes to the grammar, simply delete this file and regenerate.

package testgen

import (
	"reflect"
	"strconv"

	"github.com/alecthomas/participle/v2"
)

var _ = strconv.ParseInt // Avoid unused package error

type combinedGeneratorContext struct {
	participle.GeneratedParserContext
}

func (_ combinedGenerator) ParseCombined(ctx participle.GeneratedParserContext, out interface{}) error {
	c := combinedGeneratorContext{GeneratedParserContext: ctx}
	c.parseCombined(out.(*Combined))
	return c.FinalError()
}

func (c *combinedGeneratorContext) parseCombined(out *Combined) {
	c.SuppressError()

	// group Feature+
	for matches := 0; ; {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// capture Features from Feature
		// union Feature
		// disjunction Nil | Strings | Ints | Uints | Floats | Structs | Negation | Custom | Parseable
		{
			branchCheckpoint := c.Lex.MakeCheckpoint()

			// strct Nil
			{
				var vNil Nil

				// literal "nil"
				if c.Lex.Peek().Value != "nil" {
					c.SetTokenError("")
					goto disjunction36Alt0Error
				}
				c.Lex.Next()

				branch_out.Features = append(branch_out.Features, Feature(vNil))
			}

			goto disjunction36Success
		disjunction36Alt0Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Strings
			{
				var vStrings Strings

				// sequence "str" <string>+ (<ident> ("." <ident>)*)?
				// capture Const from "str"
				// literal "str"
				if c.Lex.Peek().Value != "str" {
					c.SetTokenError("")
					goto disjunction36Alt1Error
				}
				c.AddToString(&vStrings.Const, c.Lex.Peek().Value)
				c.Lex.Next()

				// group <string>+
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vStrings := vStrings

					// capture Quoted from <string>
					// reference <string>
					if c.Lex.Peek().Type != -6 {
						c.SetTokenError("")
						goto group75Error
					}
					c.AddToString(&branch_vStrings.Quoted, c.Lex.Peek().Value)
					c.Lex.Next()

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of <string>+ (> 10)")
						goto disjunction36Alt1Error
					}
					vStrings.Quoted = branch_vStrings.Quoted
					continue
				group75Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt1Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					if matches == 0 {
						c.SetParseError("sub-expression <string>+ must match at least once")
						goto disjunction36Alt1Error
					}
					break
				}

				// group (<ident> ("." <ident>)*)?
				for {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vStrings := vStrings

					// capture Ptr from (<ident> ("." <ident>)*)
					{
						var bufPtr string
						// sequence <ident> ("." <ident>)*
						// reference <ident>
						if c.Lex.Peek().Type != -2 {
							c.SetTokenError("")
							goto group109Error
						}
						bufPtr = c.Lex.Peek().Value
						c.Lex.Next()

						// group ("." <ident>)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()
							bufPtrCheckpoint := bufPtr

							// sequence "." <ident>
							// literal "."
							if c.Lex.Peek().Value != "." {
								c.SetTokenError("")
								goto group126Error
							}
							bufPtr += c.Lex.Peek().Value
							c.Lex.Next()

							// reference <ident>
							if c.Lex.Peek().Type != -2 {
								c.SetTokenError("<ident>")
								goto group126Error
							}
							bufPtr += c.Lex.Peek().Value
							c.Lex.Next()

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\".\" <ident>)* (> 10)")
								goto group109Error
							}
							continue
						group126Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group109Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							bufPtr = bufPtrCheckpoint
							c.SuppressError()
							break
						}

						{
							var ptrValue1 string
							if branch_vStrings.Ptr != nil {
								ptrValue1 = *branch_vStrings.Ptr
							}
							c.AddToString(&ptrValue1, bufPtr)
							branch_vStrings.Ptr = &ptrValue1
						}
					}

					vStrings.Ptr = branch_vStrings.Ptr
					break
				group109Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt1Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vStrings))
			}

			goto disjunction36Success
		disjunction36Alt1Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Ints
			{
				var vInts Ints

				// sequence "int" <int> <int>* ("-" <int>)?
				// literal "int"
				if c.Lex.Peek().Value != "int" {
					c.SetTokenError("")
					goto disjunction36Alt2Error
				}
				c.Lex.Next()

				// capture Normal from <int>
				// reference <int>
				if c.Lex.Peek().Type != -3 {
					c.SetTokenError("<int> <int>* (\"-\" <int>)?")
					goto disjunction36Alt2Error
				}
				if numValue, err := strconv.ParseInt(c.Lex.Peek().Value, 0, 64); err != nil {
					c.Lex.Next()
					c.SetCustomError("Ints.Normal", err)
					goto disjunction36Alt2Error
				} else {
					vInts.Normal = numValue
				}
				c.Lex.Next()

				// group <int>*
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vInts := vInts

					// capture Array from <int>
					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("")
						goto group222Error
					}
					{
						var sliceItem1 int16
						if numValue, err := strconv.ParseInt(c.Lex.Peek().Value, 0, 16); err != nil {
							c.Lex.Next()
							c.SetCustomError("Ints.Array", err)
							goto disjunction36Alt2Error
						} else {
							sliceItem1 = int16(numValue)
						}
						branch_vInts.Array = append(branch_vInts.Array, sliceItem1)
					}
					c.Lex.Next()

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of <int>* (> 10)")
						goto disjunction36Alt2Error
					}
					vInts.Array = branch_vInts.Array
					continue
				group222Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt2Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				// group ("-" <int>)?
				for {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vInts := vInts

					// capture Ptr from ("-" <int>)
					{
						var bufPtr string
						// sequence "-" <int>
						// literal "-"
						if c.Lex.Peek().Value != "-" {
							c.SetTokenError("")
							goto group262Error
						}
						bufPtr = c.Lex.Peek().Value
						c.Lex.Next()

						// reference <int>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("<int>")
							goto group262Error
						}
						bufPtr += c.Lex.Peek().Value
						c.Lex.Next()

						{
							var ptrValue1 int8
							if branch_vInts.Ptr != nil {
								ptrValue1 = *branch_vInts.Ptr
							}
							if numValue, err := strconv.ParseInt(bufPtr, 0, 8); err != nil {
								c.SetCustomError("Ints.Ptr", err)
								goto disjunction36Alt2Error
							} else {
								ptrValue1 = int8(numValue)
							}
							branch_vInts.Ptr = &ptrValue1
						}
					}

					vInts.Ptr = branch_vInts.Ptr
					break
				group262Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt2Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vInts))
			}

			goto disjunction36Success
		disjunction36Alt2Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Uints
			{
				var vUints Uints

				// sequence "uint" ("-"? <int>) ((<int> <int>) <int> <int>)*
				// literal "uint"
				if c.Lex.Peek().Value != "uint" {
					c.SetTokenError("")
					goto disjunction36Alt3Error
				}
				c.Lex.Next()

				// capture Normal from ("-"? <int>)
				{
					var bufNormal string
					// sequence "-"? <int>
					// group "-"?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						bufNormalCheckpoint := bufNormal

						// literal "-"
						if c.Lex.Peek().Value != "-" {
							c.SetTokenError("")
							goto group339Error
						}
						bufNormal = c.Lex.Peek().Value
						c.Lex.Next()

						break
					group339Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction36Alt3Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						bufNormal = bufNormalCheckpoint
						c.SuppressError()
						break
					}

					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<int>")
						goto disjunction36Alt3Error
					}
					bufNormal += c.Lex.Peek().Value
					c.Lex.Next()

					if numValue, err := strconv.ParseUint(bufNormal, 0, 64); err != nil {
						c.SetCustomError("Uints.Normal", err)
						goto disjunction36Alt3Error
					} else {
						vUints.Normal = uint(numValue)
					}
				}

				// group ((<int> <int>) <int> <int>)*
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vUints := vUints

					// sequence (<int> <int>) <int> <int>
					// capture Small from (<int> <int>)
					{
						var bufSmall string
						// sequence <int> <int>
						// reference <int>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("")
							goto group379Error
						}
						bufSmall = c.Lex.Peek().Value
						c.Lex.Next()

						// reference <int>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("<int>")
							goto group379Error
						}
						bufSmall += c.Lex.Peek().Value
						c.Lex.Next()

						{
							var ptrValue1 uint32
							if branch_vUints.Small != nil {
								ptrValue1 = *branch_vUints.Small
							}
							if numValue, err := strconv.ParseUint(bufSmall, 0, 32); err != nil {
								c.SetCustomError("Uints.Small", err)
								goto disjunction36Alt3Error
							} else {
								ptrValue1 = uint32(numValue)
							}
							branch_vUints.Small = &ptrValue1
						}
					}

					// capture Big from <int>
					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<int> <int>")
						goto group379Error
					}
					{
						var sliceItem1 uint64
						if numValue, err := strconv.ParseUint(c.Lex.Peek().Value, 0, 64); err != nil {
							c.Lex.Next()
							c.SetCustomError("Uints.Big", err)
							goto disjunction36Alt3Error
						} else {
							sliceItem1 = numValue
						}
						branch_vUints.Big = append(branch_vUints.Big, sliceItem1)
					}
					c.Lex.Next()

					// capture Big from <int>
					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<int>")
						goto group379Error
					}
					{
						var sliceItem1 uint64
						if numValue, err := strconv.ParseUint(c.Lex.Peek().Value, 0, 64); err != nil {
							c.Lex.Next()
							c.SetCustomError("Uints.Big", err)
							goto disjunction36Alt3Error
						} else {
							sliceItem1 = numValue
						}
						branch_vUints.Big = append(branch_vUints.Big, sliceItem1)
					}
					c.Lex.Next()

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of ((<int> <int>) <int> <int>)* (> 10)")
						goto disjunction36Alt3Error
					}
					vUints.Small = branch_vUints.Small
					vUints.Big = branch_vUints.Big
					continue
				group379Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt3Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vUints))
			}

			goto disjunction36Success
		disjunction36Alt3Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Floats
			{
				var vFloats Floats

				// sequence "float" (<int> ("." <int>)?) (<float> | <int>)?
				// literal "float"
				if c.Lex.Peek().Value != "float" {
					c.SetTokenError("")
					goto disjunction36Alt4Error
				}
				c.Lex.Next()

				// capture A from (<int> ("." <int>)?)
				{
					var bufA string
					// sequence <int> ("." <int>)?
					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("(<int> (\".\" <int>)?) (<float> | <int>)?")
						goto disjunction36Alt4Error
					}
					bufA = c.Lex.Peek().Value
					c.Lex.Next()

					// group ("." <int>)?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						bufACheckpoint := bufA
						branch_vFloats := vFloats

						// sequence "." <int>
						// literal "."
						if c.Lex.Peek().Value != "." {
							c.SetTokenError("")
							goto group509Error
						}
						bufA += c.Lex.Peek().Value
						c.Lex.Next()

						// reference <int>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("<int>")
							goto group509Error
						}
						bufA += c.Lex.Peek().Value
						c.Lex.Next()

						_ = branch_vFloats
						break
					group509Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction36Alt4Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						bufA = bufACheckpoint
						c.SuppressError()
						break
					}

					{
						var ptrValue1 float64
						if vFloats.A != nil {
							ptrValue1 = *vFloats.A
						}
						if numValue, err := strconv.ParseFloat(bufA, 64); err != nil {
							c.SetCustomError("Floats.A", err)
							goto disjunction36Alt4Error
						} else {
							ptrValue1 = numValue
						}
						vFloats.A = &ptrValue1
					}
				}

				// group (<float> | <int>)?
				for {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vFloats := vFloats

					// capture B from (<float> | <int>)
					{
						var bufB string
						// disjunction <float> | <int>
						{
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// reference <float>
							if c.Lex.Peek().Type != -4 {
								c.SetTokenError("")
								goto disjunction567Alt0Error
							}
							bufB = c.Lex.Peek().Value
							c.Lex.Next()

							goto disjunction567Success
						disjunction567Alt0Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group559Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)

							// reference <int>
							if c.Lex.Peek().Type != -3 {
								c.SetTokenError("")
								goto disjunction567Alt1Error
							}
							bufB += c.Lex.Peek().Value
							c.Lex.Next()

							goto disjunction567Success
						disjunction567Alt1Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group559Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							goto group559Error
						}
					disjunction567Success:
						c.SuppressError()

						if numValue, err := strconv.ParseFloat(bufB, 32); err != nil {
							c.SetCustomError("Floats.B", err)
							goto disjunction36Alt4Error
						} else {
							branch_vFloats.B = float32(numValue)
						}
					}

					vFloats.B = branch_vFloats.B
					break
				group559Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt4Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vFloats))
			}

			goto disjunction36Success
		disjunction36Alt4Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Structs
			{
				var vStructs Structs

				// sequence "struct" Root Rec+ ("[" Root ("," Root)* "]")?
				// literal "struct"
				if c.Lex.Peek().Value != "struct" {
					c.SetTokenError("")
					goto disjunction36Alt5Error
				}
				c.Lex.Next()

				// capture Normal from Root
				// strct Root
				{
					var vRoot Root
					c.parseRoot(&vRoot)
					if c.HasErr() {
						c.AddTokenErrorExpected("Root Rec+ (\"[\" Root (\",\" Root)* \"]\")?")
						goto disjunction36Alt5Error
					}
					vStructs.Normal = vRoot
				}

				// group Rec+
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vStructs := vStructs

					// capture Array from Rec
					// strct Rec
					{
						var vRec Rec
						c.parseRec(&vRec)
						if c.HasErr() {
							goto group658Error
						}
						branch_vStructs.Array = append(branch_vStructs.Array, vRec)
					}

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of Rec+ (> 10)")
						goto disjunction36Alt5Error
					}
					vStructs.Array = branch_vStructs.Array
					continue
				group658Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt5Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					if matches == 0 {
						c.SetParseError("sub-expression Rec+ must match at least once")
						goto disjunction36Alt5Error
					}
					break
				}

				// group ("[" Root ("," Root)* "]")?
				for {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vStructs := vStructs

					// sequence "[" Root ("," Root)* "]"
					// literal "["
					if c.Lex.Peek().Value != "[" {
						c.SetTokenError("")
						goto group694Error
					}
					c.Lex.Next()

					// capture PtrArray from Root
					// strct Root
					{
						var vRoot Root
						c.parseRoot(&vRoot)
						if c.HasErr() {
							c.AddTokenErrorExpected("Root (\",\" Root)* \"]\"")
							goto group694Error
						}
						branch_vStructs.PtrArray = append(branch_vStructs.PtrArray, &vRoot)
					}

					// group ("," Root)*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()

						// sequence "," Root
						// literal ","
						if c.Lex.Peek().Value != "," {
							c.SetTokenError("")
							goto group719Error
						}
						c.Lex.Next()

						// capture PtrArray from Root
						// strct Root
						{
							var vRoot Root
							c.parseRoot(&vRoot)
							if c.HasErr() {
								c.AddTokenErrorExpected("Root")
								goto group719Error
							}
							branch_vStructs.PtrArray = append(branch_vStructs.PtrArray, &vRoot)
						}

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of (\",\" Root)* (> 10)")
							goto group694Error
						}
						continue
					group719Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto group694Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "]"
					if c.Lex.Peek().Value != "]" {
						c.SetTokenError("\"]\"")
						goto group694Error
					}
					c.Lex.Next()

					vStructs.PtrArray = branch_vStructs.PtrArray
					break
				group694Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt5Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vStructs))
			}

			goto disjunction36Success
		disjunction36Alt5Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Negation
			{
				var vNegation Negation

				// sequence "negation" ~(<ident> | ("." "." "." "."+) | "42")* <int>?
				// literal "negation"
				if c.Lex.Peek().Value != "negation" {
					c.SetTokenError("")
					goto disjunction36Alt6Error
				}
				c.Lex.Next()

				// group ~(<ident> | ("." "." "." "."+) | "42")*
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vNegation := vNegation

					// capture Trash from ~(<ident> | ("." "." "." "."+) | "42")
					// negation ~(<ident> | ("." "." "." "."+) | "42")
					if c.Lex.Peek().EOF() {
						goto group798Error
					}
					{
						branchCheckpoint := c.Lex.MakeCheckpoint()
						// disjunction <ident> | ("." "." "." "."+) | "42"
						{
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// reference <ident>
							if c.Lex.Peek().Type != -2 {
								c.SetTokenError("")
								goto disjunction810Alt0Error
							}
							c.Lex.Next()

							goto disjunction810Success
						disjunction810Alt0Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto negation804Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)

							// sequence "." "." "." "."+
							// literal "."
							if c.Lex.Peek().Value != "." {
								c.SetTokenError("")
								goto disjunction810Alt1Error
							}
							c.Lex.Next()

							// literal "."
							if c.Lex.Peek().Value != "." {
								c.SetTokenError("\".\" \".\" \".\"+")
								goto disjunction810Alt1Error
							}
							c.Lex.Next()

							// literal "."
							if c.Lex.Peek().Value != "." {
								c.SetTokenError("\".\" \".\"+")
								goto disjunction810Alt1Error
							}
							c.Lex.Next()

							// group "."+
							for matches := 0; ; {
								branchCheckpoint := c.Lex.MakeCheckpoint()

								// literal "."
								if c.Lex.Peek().Value != "." {
									c.SetTokenError("")
									goto group850Error
								}
								c.Lex.Next()

								matches += 1
								if matches >= participle.MaxIterations {
									c.SetParseError("too many iterations of \".\"+ (> 10)")
									goto disjunction810Alt1Error
								}
								continue
							group850Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto disjunction810Alt1Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								if matches == 0 {
									c.SetParseError("sub-expression \".\"+ must match at least once")
									goto disjunction810Alt1Error
								}
								break
							}

							goto disjunction810Success
						disjunction810Alt1Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto negation804Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)

							// literal "42"
							if c.Lex.Peek().Value != "42" {
								c.SetTokenError("")
								goto disjunction810Alt2Error
							}
							c.Lex.Next()

							goto disjunction810Success
						disjunction810Alt2Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto negation804Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							goto negation804Error
						}
					disjunction810Success:
						c.SuppressError()

						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.ResetError()
						c.SetTokenError("")
						goto group798Error
					negation804Error:
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.ResetError()
						{
							var sliceItem1 string
							c.AddToString(&sliceItem1, c.Lex.Peek().Value)
							branch_vNegation.Trash = append(branch_vNegation.Trash, sliceItem1)
						}
						c.Lex.Next()
					}

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of ~(<ident> | (\".\" \".\" \".\" \".\"+) | \"42\")* (> 10)")
						goto disjunction36Alt6Error
					}
					vNegation.Trash = branch_vNegation.Trash
					continue
				group798Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt6Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				// group <int>?
				for {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vNegation := vNegation

					// capture Answer from <int>
					// reference <int>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("")
						goto group936Error
					}
					if numValue, err := strconv.ParseInt(c.Lex.Peek().Value, 0, 64); err != nil {
						c.Lex.Next()
						c.SetCustomError("Negation.Answer", err)
						goto disjunction36Alt6Error
					} else {
						branch_vNegation.Answer = int(numValue)
					}
					c.Lex.Next()

					vNegation.Answer = branch_vNegation.Answer
					break
				group936Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt6Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				branch_out.Features = append(branch_out.Features, Feature(vNegation))
			}

			goto disjunction36Success
		disjunction36Alt6Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// strct Custom
			{
				var vCustom Custom

				// sequence "custom" (CustomContent "-")* CustomContent
				// literal "custom"
				if c.Lex.Peek().Value != "custom" {
					c.SetTokenError("")
					goto disjunction36Alt7Error
				}
				c.Lex.Next()

				// group (CustomContent "-")*
				for matches := 0; ; {
					branchCheckpoint := c.Lex.MakeCheckpoint()
					branch_vCustom := vCustom

					// sequence CustomContent "-"
					// capture Opt from CustomContent
					// custom CustomContent
					if customResult, customSuccess := c.InvokeCustom(0); customSuccess {
						vCustomContent := customResult.(CustomContent)
						branch_vCustom.Opt = vCustomContent
					} else {
						goto group989Error
					}

					// literal "-"
					if c.Lex.Peek().Value != "-" {
						c.SetTokenError("\"-\"")
						goto group989Error
					}
					c.Lex.Next()

					matches += 1
					if matches >= participle.MaxIterations {
						c.SetParseError("too many iterations of (CustomContent \"-\")* (> 10)")
						goto disjunction36Alt7Error
					}
					vCustom.Opt = branch_vCustom.Opt
					continue
				group989Error:
					if c.AboveLookahead(branchCheckpoint) {
						goto disjunction36Alt7Error
					}
					c.Lex.LoadCheckpoint(branchCheckpoint)
					c.SuppressError()
					break
				}

				// capture Req from CustomContent
				// custom CustomContent
				if customResult, customSuccess := c.InvokeCustom(0); customSuccess {
					vCustomContent := customResult.(CustomContent)
					vCustom.Req = vCustomContent
				} else {
					goto disjunction36Alt7Error
				}

				branch_out.Features = append(branch_out.Features, Feature(vCustom))
			}

			goto disjunction36Success
		disjunction36Alt7Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)

			// parseable testgen.Parseable
			var vParseable Parseable
			if err := vParseable.Parse(c.Lex); err == participle.NextMatch {
				goto disjunction36Alt8Error
			} else if err != nil {
				c.SetCustomError("", err)
				goto disjunction36Alt8Error
			}
			branch_out.Features = append(branch_out.Features, Feature(vParseable))

			goto disjunction36Success
		disjunction36Alt8Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group29Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			goto group29Error
		}
	disjunction36Success:
		c.SuppressError()

		matches += 1
		if matches >= participle.MaxIterations {
			c.SetParseError("too many iterations of Feature+ (> 10)")
			goto strctCombined26Error
		}
		out.Features = branch_out.Features
		continue
	group29Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctCombined26Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		if matches == 0 {
			c.SetParseError("sub-expression Feature+ must match at least once")
			goto strctCombined26Error
		}
		break
	}

strctCombined26Error:
}

func (_ combinedGenerator) ParseRoot(ctx participle.GeneratedParserContext, out interface{}) error {
	c := combinedGeneratorContext{GeneratedParserContext: ctx}
	c.parseRoot(out.(*Root))
	return c.FinalError()
}

func (c *combinedGeneratorContext) parseRoot(out *Root) {
	c.SuppressError()

	// capture Str from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -2 {
		c.SetTokenError("")
		goto strctRoot1096Error
	}
	c.AddToString(&out.Str, c.Lex.Peek().Value)
	c.Lex.Next()

strctRoot1096Error:
}

func (_ combinedGenerator) ParseRec(ctx participle.GeneratedParserContext, out interface{}) error {
	c := combinedGeneratorContext{GeneratedParserContext: ctx}
	c.parseRec(out.(*Rec))
	return c.FinalError()
}

func (c *combinedGeneratorContext) parseRec(out *Rec) {
	c.SuppressError()

	// disjunction Root | ("{" Rec "}")
	{
		branchCheckpoint := c.Lex.MakeCheckpoint()

		// capture Root from Root
		// strct Root
		{
			var vRoot Root
			c.parseRoot(&vRoot)
			if c.HasErr() {
				goto disjunction1120Alt0Error
			}
			out.Root = vRoot
		}

		goto disjunction1120Success
	disjunction1120Alt0Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctRec1117Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// sequence "{" Rec "}"
		// literal "{"
		if c.Lex.Peek().Value != "{" {
			c.SetTokenError("")
			goto disjunction1120Alt1Error
		}
		c.Lex.Next()

		// capture In from Rec
		// strct Rec
		{
			var vRec Rec
			c.parseRec(&vRec)
			if c.HasErr() {
				c.AddTokenErrorExpected("Rec \"}\"")
				goto disjunction1120Alt1Error
			}
			out.In = &vRec
		}

		// literal "}"
		if c.Lex.Peek().Value != "}" {
			c.SetTokenError("\"}\"")
			goto disjunction1120Alt1Error
		}
		c.Lex.Next()

		goto disjunction1120Success
	disjunction1120Alt1Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctRec1117Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		goto strctRec1117Error
	}
disjunction1120Success:
	c.SuppressError()

strctRec1117Error:
}

// GeneratedParsers exposes non-inlined methods for sub-parsing.
func (g combinedGenerator) GeneratedParsers() participle.GeneratedParserFns {
	// The entrypoint to the generated code. Basically a static method. Shadows embedded method.
	return participle.GeneratedParserFns{
		reflect.TypeOf((*Combined)(nil)): g.ParseCombined,
		reflect.TypeOf((*Root)(nil)):     g.ParseRoot,
		reflect.TypeOf((*Rec)(nil)):      g.ParseRec,
	}
}
