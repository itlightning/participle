// Code generated by participle parser generator. DO NOT EDIT.
// source: main.Thrift
// If code breaks after changes to the grammar, simply delete this file and regenerate.

package main

import (
	"reflect"
	"strconv"

	"github.com/alecthomas/participle/v2"
)

var _ = strconv.ParseInt // Avoid unused package error

type parserGeneratorContext struct {
	participle.GeneratedParserContext
}

func (_ generatedParser) ParseThrift(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseThrift(out.(*Thrift))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseThrift(out *Thrift) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// group Entry*
	for matches := 0; ; {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// capture Entries from Entry
		// strct Entry
		{
			var vEntry Entry
			vEntry.Pos = c.Lex.Peek().Pos

			// disjunction ("include" <string>) | Namespace | Struct | Exception | Service | Enum | Typedef | Const
			{
				branchCheckpoint := c.Lex.MakeCheckpoint()

				// sequence "include" <string>
				// literal "include"
				if c.Lex.Peek().Value != "include" {
					c.SetTokenError("")
					goto disjunction41Alt0Error
				}
				c.Lex.Next()

				// capture Includes from <string>
				// reference <string>
				if c.Lex.Peek().Type != -4 {
					c.SetTokenError("<string>")
					goto disjunction41Alt0Error
				}
				{
					var sliceItem1 string
					c.AddToString(&sliceItem1, c.Lex.Peek().Value)
					vEntry.Includes = append(vEntry.Includes, sliceItem1)
				}
				c.Lex.Next()

				goto disjunction41Success
			disjunction41Alt0Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Namespaces from Namespace
				// strct Namespace
				{
					var vNamespace Namespace
					vNamespace.Pos = c.Lex.Peek().Pos

					// sequence "namespace" <ident> <ident> ("." <ident>)*
					// literal "namespace"
					if c.Lex.Peek().Value != "namespace" {
						c.SetTokenError("")
						goto disjunction41Alt1Error
					}
					c.Lex.Next()

					// capture Language from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> <ident> (\".\" <ident>)*")
						goto disjunction41Alt1Error
					}
					c.AddToString(&vNamespace.Language, c.Lex.Peek().Value)
					c.Lex.Next()

					// capture Namespace from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> (\".\" <ident>)*")
						goto disjunction41Alt1Error
					}
					c.AddToString(&vNamespace.Namespace, c.Lex.Peek().Value)
					c.Lex.Next()

					// group ("." <ident>)*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vNamespace := vNamespace

						// sequence "." <ident>
						// capture Namespace from "."
						// literal "."
						if c.Lex.Peek().Value != "." {
							c.SetTokenError("")
							goto group105Error
						}
						c.AddToString(&branch_vNamespace.Namespace, c.Lex.Peek().Value)
						c.Lex.Next()

						// capture Namespace from <ident>
						// reference <ident>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("<ident>")
							goto group105Error
						}
						c.AddToString(&branch_vNamespace.Namespace, c.Lex.Peek().Value)
						c.Lex.Next()

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of (\".\" <ident>)* (> 1000000)")
							goto disjunction41Alt1Error
						}
						vNamespace.Namespace = branch_vNamespace.Namespace
						continue
					group105Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt1Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Namespaces = append(vEntry.Namespaces, vNamespace)
				}

				goto disjunction41Success
			disjunction41Alt1Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Structs from Struct
				// strct Struct
				{
					var vStruct Struct
					vStruct.Pos = c.Lex.Peek().Pos

					// sequence ("struct" | "union") <ident> "{" Field* "}" ("(" Annotation ("," Annotation)* ")")?
					// disjunction "struct" | "union"
					{
						branchCheckpoint := c.Lex.MakeCheckpoint()

						// literal "struct"
						if c.Lex.Peek().Value != "struct" {
							c.SetTokenError("")
							goto disjunction162Alt0Error
						}
						c.Lex.Next()

						goto disjunction162Success
					disjunction162Alt0Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt2Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)

						// capture Union from "union"
						// literal "union"
						if c.Lex.Peek().Value != "union" {
							c.SetTokenError("")
							goto disjunction162Alt1Error
						}
						vStruct.Union = true
						c.Lex.Next()

						goto disjunction162Success
					disjunction162Alt1Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt2Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						goto disjunction41Alt2Error
					}
				disjunction162Success:
					c.SuppressError()

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> \"{\" Field* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt2Error
					}
					c.AddToString(&vStruct.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					// literal "{"
					if c.Lex.Peek().Value != "{" {
						c.SetTokenError("\"{\" Field* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt2Error
					}
					c.Lex.Next()

					// group Field*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vStruct := vStruct

						// capture Fields from Field
						// strct Field
						{
							var vField Field
							c.parseField(&vField)
							if c.HasErr() {
								goto group216Error
							}
							branch_vStruct.Fields = append(branch_vStruct.Fields, vField)
						}

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of Field* (> 1000000)")
							goto disjunction41Alt2Error
						}
						vStruct.Fields = branch_vStruct.Fields
						continue
					group216Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt2Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "}"
					if c.Lex.Peek().Value != "}" {
						c.SetTokenError("\"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt2Error
					}
					c.Lex.Next()

					// group ("(" Annotation ("," Annotation)* ")")?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vStruct := vStruct

						// sequence "(" Annotation ("," Annotation)* ")"
						// literal "("
						if c.Lex.Peek().Value != "(" {
							c.SetTokenError("")
							goto group255Error
						}
						c.Lex.Next()

						// capture Annotations from Annotation
						// strct Annotation
						{
							var vAnnotation Annotation
							c.parseAnnotation(&vAnnotation)
							if c.HasErr() {
								c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
								goto group255Error
							}
							branch_vStruct.Annotations = append(branch_vStruct.Annotations, vAnnotation)
						}

						// group ("," Annotation)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// sequence "," Annotation
							// literal ","
							if c.Lex.Peek().Value != "," {
								c.SetTokenError("")
								goto group280Error
							}
							c.Lex.Next()

							// capture Annotations from Annotation
							// strct Annotation
							{
								var vAnnotation Annotation
								c.parseAnnotation(&vAnnotation)
								if c.HasErr() {
									c.AddTokenErrorExpected("Annotation")
									goto group280Error
								}
								branch_vStruct.Annotations = append(branch_vStruct.Annotations, vAnnotation)
							}

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
								goto group255Error
							}
							continue
						group280Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group255Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						// literal ")"
						if c.Lex.Peek().Value != ")" {
							c.SetTokenError("\")\"")
							goto group255Error
						}
						c.Lex.Next()

						vStruct.Annotations = branch_vStruct.Annotations
						break
					group255Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt2Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Structs = append(vEntry.Structs, vStruct)
				}

				goto disjunction41Success
			disjunction41Alt2Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Exceptions from Exception
				// strct Exception
				{
					var vException Exception
					vException.Pos = c.Lex.Peek().Pos

					// sequence "exception" <ident> "{" Field Field* "}" ("(" Annotation ("," Annotation)* ")")?
					// literal "exception"
					if c.Lex.Peek().Value != "exception" {
						c.SetTokenError("")
						goto disjunction41Alt3Error
					}
					c.Lex.Next()

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> \"{\" Field Field* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt3Error
					}
					c.AddToString(&vException.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					// literal "{"
					if c.Lex.Peek().Value != "{" {
						c.SetTokenError("\"{\" Field Field* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt3Error
					}
					c.Lex.Next()

					// capture Fields from Field
					// strct Field
					{
						var vField Field
						c.parseField(&vField)
						if c.HasErr() {
							c.AddTokenErrorExpected("Field Field* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
							goto disjunction41Alt3Error
						}
						vException.Fields = append(vException.Fields, vField)
					}

					// group Field*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vException := vException

						// capture Fields from Field
						// strct Field
						{
							var vField Field
							c.parseField(&vField)
							if c.HasErr() {
								goto group389Error
							}
							branch_vException.Fields = append(branch_vException.Fields, vField)
						}

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of Field* (> 1000000)")
							goto disjunction41Alt3Error
						}
						vException.Fields = branch_vException.Fields
						continue
					group389Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt3Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "}"
					if c.Lex.Peek().Value != "}" {
						c.SetTokenError("\"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt3Error
					}
					c.Lex.Next()

					// group ("(" Annotation ("," Annotation)* ")")?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vException := vException

						// sequence "(" Annotation ("," Annotation)* ")"
						// literal "("
						if c.Lex.Peek().Value != "(" {
							c.SetTokenError("")
							goto group428Error
						}
						c.Lex.Next()

						// capture Annotations from Annotation
						// strct Annotation
						{
							var vAnnotation Annotation
							c.parseAnnotation(&vAnnotation)
							if c.HasErr() {
								c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
								goto group428Error
							}
							branch_vException.Annotations = append(branch_vException.Annotations, vAnnotation)
						}

						// group ("," Annotation)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// sequence "," Annotation
							// literal ","
							if c.Lex.Peek().Value != "," {
								c.SetTokenError("")
								goto group453Error
							}
							c.Lex.Next()

							// capture Annotations from Annotation
							// strct Annotation
							{
								var vAnnotation Annotation
								c.parseAnnotation(&vAnnotation)
								if c.HasErr() {
									c.AddTokenErrorExpected("Annotation")
									goto group453Error
								}
								branch_vException.Annotations = append(branch_vException.Annotations, vAnnotation)
							}

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
								goto group428Error
							}
							continue
						group453Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group428Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						// literal ")"
						if c.Lex.Peek().Value != ")" {
							c.SetTokenError("\")\"")
							goto group428Error
						}
						c.Lex.Next()

						vException.Annotations = branch_vException.Annotations
						break
					group428Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt3Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Exceptions = append(vEntry.Exceptions, vException)
				}

				goto disjunction41Success
			disjunction41Alt3Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Services from Service
				// strct Service
				{
					var vService Service
					vService.Pos = c.Lex.Peek().Pos

					// sequence "service" <ident> ("extends" <ident> ("." <ident>)*)? "{" (Method ";"?)* "}" ("(" Annotation ("," Annotation)* ")")?
					// literal "service"
					if c.Lex.Peek().Value != "service" {
						c.SetTokenError("")
						goto disjunction41Alt4Error
					}
					c.Lex.Next()

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> (\"extends\" <ident> (\".\" <ident>)*)? \"{\" (Method \";\"?)* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt4Error
					}
					c.AddToString(&vService.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					// group ("extends" <ident> ("." <ident>)*)?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vService := vService

						// sequence "extends" <ident> ("." <ident>)*
						// literal "extends"
						if c.Lex.Peek().Value != "extends" {
							c.SetTokenError("")
							goto group543Error
						}
						c.Lex.Next()

						// capture Extends from <ident>
						// reference <ident>
						if c.Lex.Peek().Type != -3 {
							c.SetTokenError("<ident> (\".\" <ident>)*")
							goto group543Error
						}
						c.AddToString(&branch_vService.Extends, c.Lex.Peek().Value)
						c.Lex.Next()

						// group ("." <ident>)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// sequence "." <ident>
							// capture Extends from "."
							// literal "."
							if c.Lex.Peek().Value != "." {
								c.SetTokenError("")
								goto group565Error
							}
							c.AddToString(&branch_vService.Extends, c.Lex.Peek().Value)
							c.Lex.Next()

							// capture Extends from <ident>
							// reference <ident>
							if c.Lex.Peek().Type != -3 {
								c.SetTokenError("<ident>")
								goto group565Error
							}
							c.AddToString(&branch_vService.Extends, c.Lex.Peek().Value)
							c.Lex.Next()

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\".\" <ident>)* (> 1000000)")
								goto group543Error
							}
							continue
						group565Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group543Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						vService.Extends = branch_vService.Extends
						break
					group543Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt4Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "{"
					if c.Lex.Peek().Value != "{" {
						c.SetTokenError("\"{\" (Method \";\"?)* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt4Error
					}
					c.Lex.Next()

					// group (Method ";"?)*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vService := vService

						// sequence Method ";"?
						// capture Methods from Method
						// strct Method
						{
							var vMethod Method
							vMethod.Pos = c.Lex.Peek().Pos

							// sequence Type <ident> "(" (Argument ("," Argument)*)? ")" ("throws" "(" Throw ("," Throw)* ")")? ("(" Annotation ("," Annotation)* ")")?
							// capture ReturnType from Type
							// strct Type
							{
								var vType Type
								c.parseType(&vType)
								if c.HasErr() {
									goto group621Error
								}
								vMethod.ReturnType = vType
							}

							// capture Name from <ident>
							// reference <ident>
							if c.Lex.Peek().Type != -3 {
								c.SetTokenError("<ident> \"(\" (Argument (\",\" Argument)*)? \")\" (\"throws\" \"(\" Throw (\",\" Throw)* \")\")? (\"(\" Annotation (\",\" Annotation)* \")\")?")
								goto group621Error
							}
							c.AddToString(&vMethod.Name, c.Lex.Peek().Value)
							c.Lex.Next()

							// literal "("
							if c.Lex.Peek().Value != "(" {
								c.SetTokenError("\"(\" (Argument (\",\" Argument)*)? \")\" (\"throws\" \"(\" Throw (\",\" Throw)* \")\")? (\"(\" Annotation (\",\" Annotation)* \")\")?")
								goto group621Error
							}
							c.Lex.Next()

							// group (Argument ("," Argument)*)?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vMethod := vMethod

								// sequence Argument ("," Argument)*
								// capture Arguments from Argument
								// strct Argument
								{
									var vArgument Argument
									c.parseArgument(&vArgument)
									if c.HasErr() {
										goto group661Error
									}
									branch_vMethod.Arguments = append(branch_vMethod.Arguments, vArgument)
								}

								// group ("," Argument)*
								for matches := 0; ; {
									branchCheckpoint := c.Lex.MakeCheckpoint()

									// sequence "," Argument
									// literal ","
									if c.Lex.Peek().Value != "," {
										c.SetTokenError("")
										goto group678Error
									}
									c.Lex.Next()

									// capture Arguments from Argument
									// strct Argument
									{
										var vArgument Argument
										c.parseArgument(&vArgument)
										if c.HasErr() {
											c.AddTokenErrorExpected("Argument")
											goto group678Error
										}
										branch_vMethod.Arguments = append(branch_vMethod.Arguments, vArgument)
									}

									matches += 1
									if matches >= participle.MaxIterations {
										c.SetParseError("too many iterations of (\",\" Argument)* (> 1000000)")
										goto group661Error
									}
									continue
								group678Error:
									if c.AboveLookahead(branchCheckpoint) {
										goto group661Error
									}
									c.Lex.LoadCheckpoint(branchCheckpoint)
									c.SuppressError()
									break
								}

								vMethod.Arguments = branch_vMethod.Arguments
								break
							group661Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group621Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							// literal ")"
							if c.Lex.Peek().Value != ")" {
								c.SetTokenError("\")\" (\"throws\" \"(\" Throw (\",\" Throw)* \")\")? (\"(\" Annotation (\",\" Annotation)* \")\")?")
								goto group621Error
							}
							c.Lex.Next()

							// group ("throws" "(" Throw ("," Throw)* ")")?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vMethod := vMethod

								// sequence "throws" "(" Throw ("," Throw)* ")"
								// literal "throws"
								if c.Lex.Peek().Value != "throws" {
									c.SetTokenError("")
									goto group735Error
								}
								c.Lex.Next()

								// literal "("
								if c.Lex.Peek().Value != "(" {
									c.SetTokenError("\"(\" Throw (\",\" Throw)* \")\"")
									goto group735Error
								}
								c.Lex.Next()

								// capture Throws from Throw
								// strct Throw
								{
									var vThrow Throw
									c.parseThrow(&vThrow)
									if c.HasErr() {
										c.AddTokenErrorExpected("Throw (\",\" Throw)* \")\"")
										goto group735Error
									}
									branch_vMethod.Throws = append(branch_vMethod.Throws, vThrow)
								}

								// group ("," Throw)*
								for matches := 0; ; {
									branchCheckpoint := c.Lex.MakeCheckpoint()

									// sequence "," Throw
									// literal ","
									if c.Lex.Peek().Value != "," {
										c.SetTokenError("")
										goto group767Error
									}
									c.Lex.Next()

									// capture Throws from Throw
									// strct Throw
									{
										var vThrow Throw
										c.parseThrow(&vThrow)
										if c.HasErr() {
											c.AddTokenErrorExpected("Throw")
											goto group767Error
										}
										branch_vMethod.Throws = append(branch_vMethod.Throws, vThrow)
									}

									matches += 1
									if matches >= participle.MaxIterations {
										c.SetParseError("too many iterations of (\",\" Throw)* (> 1000000)")
										goto group735Error
									}
									continue
								group767Error:
									if c.AboveLookahead(branchCheckpoint) {
										goto group735Error
									}
									c.Lex.LoadCheckpoint(branchCheckpoint)
									c.SuppressError()
									break
								}

								// literal ")"
								if c.Lex.Peek().Value != ")" {
									c.SetTokenError("\")\"")
									goto group735Error
								}
								c.Lex.Next()

								vMethod.Throws = branch_vMethod.Throws
								break
							group735Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group621Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							// group ("(" Annotation ("," Annotation)* ")")?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vMethod := vMethod

								// sequence "(" Annotation ("," Annotation)* ")"
								// literal "("
								if c.Lex.Peek().Value != "(" {
									c.SetTokenError("")
									goto group824Error
								}
								c.Lex.Next()

								// capture Annotations from Annotation
								// strct Annotation
								{
									var vAnnotation Annotation
									c.parseAnnotation(&vAnnotation)
									if c.HasErr() {
										c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
										goto group824Error
									}
									branch_vMethod.Annotations = append(branch_vMethod.Annotations, vAnnotation)
								}

								// group ("," Annotation)*
								for matches := 0; ; {
									branchCheckpoint := c.Lex.MakeCheckpoint()

									// sequence "," Annotation
									// literal ","
									if c.Lex.Peek().Value != "," {
										c.SetTokenError("")
										goto group849Error
									}
									c.Lex.Next()

									// capture Annotations from Annotation
									// strct Annotation
									{
										var vAnnotation Annotation
										c.parseAnnotation(&vAnnotation)
										if c.HasErr() {
											c.AddTokenErrorExpected("Annotation")
											goto group849Error
										}
										branch_vMethod.Annotations = append(branch_vMethod.Annotations, vAnnotation)
									}

									matches += 1
									if matches >= participle.MaxIterations {
										c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
										goto group824Error
									}
									continue
								group849Error:
									if c.AboveLookahead(branchCheckpoint) {
										goto group824Error
									}
									c.Lex.LoadCheckpoint(branchCheckpoint)
									c.SuppressError()
									break
								}

								// literal ")"
								if c.Lex.Peek().Value != ")" {
									c.SetTokenError("\")\"")
									goto group824Error
								}
								c.Lex.Next()

								vMethod.Annotations = branch_vMethod.Annotations
								break
							group824Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group621Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							branch_vService.Methods = append(branch_vService.Methods, vMethod)
						}

						// group ";"?
						for {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// literal ";"
							if c.Lex.Peek().Value != ";" {
								c.SetTokenError("")
								goto group909Error
							}
							c.Lex.Next()

							break
						group909Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group621Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of (Method \";\"?)* (> 1000000)")
							goto disjunction41Alt4Error
						}
						vService.Methods = branch_vService.Methods
						continue
					group621Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt4Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "}"
					if c.Lex.Peek().Value != "}" {
						c.SetTokenError("\"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt4Error
					}
					c.Lex.Next()

					// group ("(" Annotation ("," Annotation)* ")")?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vService := vService

						// sequence "(" Annotation ("," Annotation)* ")"
						// literal "("
						if c.Lex.Peek().Value != "(" {
							c.SetTokenError("")
							goto group953Error
						}
						c.Lex.Next()

						// capture Annotations from Annotation
						// strct Annotation
						{
							var vAnnotation Annotation
							c.parseAnnotation(&vAnnotation)
							if c.HasErr() {
								c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
								goto group953Error
							}
							branch_vService.Annotations = append(branch_vService.Annotations, vAnnotation)
						}

						// group ("," Annotation)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// sequence "," Annotation
							// literal ","
							if c.Lex.Peek().Value != "," {
								c.SetTokenError("")
								goto group978Error
							}
							c.Lex.Next()

							// capture Annotations from Annotation
							// strct Annotation
							{
								var vAnnotation Annotation
								c.parseAnnotation(&vAnnotation)
								if c.HasErr() {
									c.AddTokenErrorExpected("Annotation")
									goto group978Error
								}
								branch_vService.Annotations = append(branch_vService.Annotations, vAnnotation)
							}

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
								goto group953Error
							}
							continue
						group978Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group953Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						// literal ")"
						if c.Lex.Peek().Value != ")" {
							c.SetTokenError("\")\"")
							goto group953Error
						}
						c.Lex.Next()

						vService.Annotations = branch_vService.Annotations
						break
					group953Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt4Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Services = append(vEntry.Services, vService)
				}

				goto disjunction41Success
			disjunction41Alt4Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Enums from Enum
				// strct Enum
				{
					var vEnum Enum
					vEnum.Pos = c.Lex.Peek().Pos

					// sequence "enum" <ident> "{" Case* "}" ("(" Annotation ("," Annotation)* ")")?
					// literal "enum"
					if c.Lex.Peek().Value != "enum" {
						c.SetTokenError("")
						goto disjunction41Alt5Error
					}
					c.Lex.Next()

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> \"{\" Case* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt5Error
					}
					c.AddToString(&vEnum.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					// literal "{"
					if c.Lex.Peek().Value != "{" {
						c.SetTokenError("\"{\" Case* \"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt5Error
					}
					c.Lex.Next()

					// group Case*
					for matches := 0; ; {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vEnum := vEnum

						// capture Cases from Case
						// strct Case
						{
							var vCase Case
							vCase.Pos = c.Lex.Peek().Pos

							// sequence <ident> ("(" Annotation ("," Annotation)* ")")? ("=" Literal)? ("," | ";")?
							// capture Name from <ident>
							// reference <ident>
							if c.Lex.Peek().Type != -3 {
								c.SetTokenError("")
								goto group1075Error
							}
							c.AddToString(&vCase.Name, c.Lex.Peek().Value)
							c.Lex.Next()

							// group ("(" Annotation ("," Annotation)* ")")?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vCase := vCase

								// sequence "(" Annotation ("," Annotation)* ")"
								// literal "("
								if c.Lex.Peek().Value != "(" {
									c.SetTokenError("")
									goto group1096Error
								}
								c.Lex.Next()

								// capture Annotations from Annotation
								// strct Annotation
								{
									var vAnnotation Annotation
									c.parseAnnotation(&vAnnotation)
									if c.HasErr() {
										c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
										goto group1096Error
									}
									branch_vCase.Annotations = append(branch_vCase.Annotations, vAnnotation)
								}

								// group ("," Annotation)*
								for matches := 0; ; {
									branchCheckpoint := c.Lex.MakeCheckpoint()

									// sequence "," Annotation
									// literal ","
									if c.Lex.Peek().Value != "," {
										c.SetTokenError("")
										goto group1121Error
									}
									c.Lex.Next()

									// capture Annotations from Annotation
									// strct Annotation
									{
										var vAnnotation Annotation
										c.parseAnnotation(&vAnnotation)
										if c.HasErr() {
											c.AddTokenErrorExpected("Annotation")
											goto group1121Error
										}
										branch_vCase.Annotations = append(branch_vCase.Annotations, vAnnotation)
									}

									matches += 1
									if matches >= participle.MaxIterations {
										c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
										goto group1096Error
									}
									continue
								group1121Error:
									if c.AboveLookahead(branchCheckpoint) {
										goto group1096Error
									}
									c.Lex.LoadCheckpoint(branchCheckpoint)
									c.SuppressError()
									break
								}

								// literal ")"
								if c.Lex.Peek().Value != ")" {
									c.SetTokenError("\")\"")
									goto group1096Error
								}
								c.Lex.Next()

								vCase.Annotations = branch_vCase.Annotations
								break
							group1096Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group1075Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							// group ("=" Literal)?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vCase := vCase

								// sequence "=" Literal
								// literal "="
								if c.Lex.Peek().Value != "=" {
									c.SetTokenError("")
									goto group1178Error
								}
								c.Lex.Next()

								// capture Value from Literal
								// strct Literal
								{
									var vLiteral Literal
									c.parseLiteral(&vLiteral)
									if c.HasErr() {
										c.AddTokenErrorExpected("Literal")
										goto group1178Error
									}
									branch_vCase.Value = &vLiteral
								}

								vCase.Value = branch_vCase.Value
								break
							group1178Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group1075Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							// group ("," | ";")?
							for {
								branchCheckpoint := c.Lex.MakeCheckpoint()
								branch_vCase := vCase

								// disjunction "," | ";"
								switch c.Lex.Peek().Value {
								case ",", ";":
									c.Lex.Next()
								default:
									c.SetTokenError("")
									goto group1214Error
								}

								_ = branch_vCase
								break
							group1214Error:
								if c.AboveLookahead(branchCheckpoint) {
									goto group1075Error
								}
								c.Lex.LoadCheckpoint(branchCheckpoint)
								c.SuppressError()
								break
							}

							branch_vEnum.Cases = append(branch_vEnum.Cases, vCase)
						}

						matches += 1
						if matches >= participle.MaxIterations {
							c.SetParseError("too many iterations of Case* (> 1000000)")
							goto disjunction41Alt5Error
						}
						vEnum.Cases = branch_vEnum.Cases
						continue
					group1075Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt5Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					// literal "}"
					if c.Lex.Peek().Value != "}" {
						c.SetTokenError("\"}\" (\"(\" Annotation (\",\" Annotation)* \")\")?")
						goto disjunction41Alt5Error
					}
					c.Lex.Next()

					// group ("(" Annotation ("," Annotation)* ")")?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()
						branch_vEnum := vEnum

						// sequence "(" Annotation ("," Annotation)* ")"
						// literal "("
						if c.Lex.Peek().Value != "(" {
							c.SetTokenError("")
							goto group1265Error
						}
						c.Lex.Next()

						// capture Annotations from Annotation
						// strct Annotation
						{
							var vAnnotation Annotation
							c.parseAnnotation(&vAnnotation)
							if c.HasErr() {
								c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
								goto group1265Error
							}
							branch_vEnum.Annotations = append(branch_vEnum.Annotations, vAnnotation)
						}

						// group ("," Annotation)*
						for matches := 0; ; {
							branchCheckpoint := c.Lex.MakeCheckpoint()

							// sequence "," Annotation
							// literal ","
							if c.Lex.Peek().Value != "," {
								c.SetTokenError("")
								goto group1290Error
							}
							c.Lex.Next()

							// capture Annotations from Annotation
							// strct Annotation
							{
								var vAnnotation Annotation
								c.parseAnnotation(&vAnnotation)
								if c.HasErr() {
									c.AddTokenErrorExpected("Annotation")
									goto group1290Error
								}
								branch_vEnum.Annotations = append(branch_vEnum.Annotations, vAnnotation)
							}

							matches += 1
							if matches >= participle.MaxIterations {
								c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
								goto group1265Error
							}
							continue
						group1290Error:
							if c.AboveLookahead(branchCheckpoint) {
								goto group1265Error
							}
							c.Lex.LoadCheckpoint(branchCheckpoint)
							c.SuppressError()
							break
						}

						// literal ")"
						if c.Lex.Peek().Value != ")" {
							c.SetTokenError("\")\"")
							goto group1265Error
						}
						c.Lex.Next()

						vEnum.Annotations = branch_vEnum.Annotations
						break
					group1265Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt5Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Enums = append(vEntry.Enums, vEnum)
				}

				goto disjunction41Success
			disjunction41Alt5Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Typedefs from Typedef
				// strct Typedef
				{
					var vTypedef Typedef
					vTypedef.Pos = c.Lex.Peek().Pos

					// sequence "typedef" Type <ident>
					// literal "typedef"
					if c.Lex.Peek().Value != "typedef" {
						c.SetTokenError("")
						goto disjunction41Alt6Error
					}
					c.Lex.Next()

					// capture Type from Type
					// strct Type
					{
						var vType Type
						c.parseType(&vType)
						if c.HasErr() {
							c.AddTokenErrorExpected("Type <ident>")
							goto disjunction41Alt6Error
						}
						vTypedef.Type = vType
					}

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident>")
						goto disjunction41Alt6Error
					}
					c.AddToString(&vTypedef.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					vEntry.Typedefs = append(vEntry.Typedefs, vTypedef)
				}

				goto disjunction41Success
			disjunction41Alt6Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)

				// capture Consts from Const
				// strct Const
				{
					var vConst Const
					vConst.Pos = c.Lex.Peek().Pos

					// sequence "const" Type <ident> "=" Literal ";"?
					// literal "const"
					if c.Lex.Peek().Value != "const" {
						c.SetTokenError("")
						goto disjunction41Alt7Error
					}
					c.Lex.Next()

					// capture Type from Type
					// strct Type
					{
						var vType Type
						c.parseType(&vType)
						if c.HasErr() {
							c.AddTokenErrorExpected("Type <ident> \"=\" Literal \";\"?")
							goto disjunction41Alt7Error
						}
						vConst.Type = vType
					}

					// capture Name from <ident>
					// reference <ident>
					if c.Lex.Peek().Type != -3 {
						c.SetTokenError("<ident> \"=\" Literal \";\"?")
						goto disjunction41Alt7Error
					}
					c.AddToString(&vConst.Name, c.Lex.Peek().Value)
					c.Lex.Next()

					// literal "="
					if c.Lex.Peek().Value != "=" {
						c.SetTokenError("\"=\" Literal \";\"?")
						goto disjunction41Alt7Error
					}
					c.Lex.Next()

					// capture Value from Literal
					// strct Literal
					{
						var vLiteral Literal
						c.parseLiteral(&vLiteral)
						if c.HasErr() {
							c.AddTokenErrorExpected("Literal \";\"?")
							goto disjunction41Alt7Error
						}
						vConst.Value = vLiteral
					}

					// group ";"?
					for {
						branchCheckpoint := c.Lex.MakeCheckpoint()

						// literal ";"
						if c.Lex.Peek().Value != ";" {
							c.SetTokenError("")
							goto group1456Error
						}
						c.Lex.Next()

						break
					group1456Error:
						if c.AboveLookahead(branchCheckpoint) {
							goto disjunction41Alt7Error
						}
						c.Lex.LoadCheckpoint(branchCheckpoint)
						c.SuppressError()
						break
					}

					vEntry.Consts = append(vEntry.Consts, vConst)
				}

				goto disjunction41Success
			disjunction41Alt7Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group30Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)
				goto group30Error
			}
		disjunction41Success:
			c.SuppressError()

			branch_out.Entries = append(branch_out.Entries, &vEntry)
		}

		matches += 1
		if matches >= participle.MaxIterations {
			c.SetParseError("too many iterations of Entry* (> 1000000)")
			goto strctThrift26Error
		}
		out.Entries = branch_out.Entries
		continue
	group30Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctThrift26Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

strctThrift26Error:
}

func (_ generatedParser) ParseField(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseField(out.(*Field))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseField(out *Field) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// sequence <number> ":" ("optional" | "required")? Type <ident> ("=" Literal)? ("(" Annotation ("," Annotation)* ")")? ";"?
	// capture ID from <number>
	// reference <number>
	if c.Lex.Peek().Type != -2 {
		c.SetTokenError("")
		goto strctField1519Error
	}
	c.AddToString(&out.ID, c.Lex.Peek().Value)
	c.Lex.Next()

	// literal ":"
	if c.Lex.Peek().Value != ":" {
		c.SetTokenError("\":\" (\"optional\" | \"required\")? Type <ident> (\"=\" Literal)? (\"(\" Annotation (\",\" Annotation)* \")\")? \";\"?")
		goto strctField1519Error
	}
	c.Lex.Next()

	// group ("optional" | "required")?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// capture Requirement from ("optional" | "required")
		// disjunction "optional" | "required"
		switch c.Lex.Peek().Value {
		case "optional", "required":
			c.AddToString(&branch_out.Requirement, c.Lex.Peek().Value)
			c.Lex.Next()
		default:
			c.SetTokenError("")
			goto group1540Error
		}

		out.Requirement = branch_out.Requirement
		break
	group1540Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctField1519Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

	// capture Type from Type
	// strct Type
	{
		var vType Type
		c.parseType(&vType)
		if c.HasErr() {
			c.AddTokenErrorExpected("Type <ident> (\"=\" Literal)? (\"(\" Annotation (\",\" Annotation)* \")\")? \";\"?")
			goto strctField1519Error
		}
		out.Type = vType
	}

	// capture Name from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -3 {
		c.SetTokenError("<ident> (\"=\" Literal)? (\"(\" Annotation (\",\" Annotation)* \")\")? \";\"?")
		goto strctField1519Error
	}
	c.AddToString(&out.Name, c.Lex.Peek().Value)
	c.Lex.Next()

	// group ("=" Literal)?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "=" Literal
		// literal "="
		if c.Lex.Peek().Value != "=" {
			c.SetTokenError("")
			goto group1588Error
		}
		c.Lex.Next()

		// capture Default from Literal
		// strct Literal
		{
			var vLiteral Literal
			c.parseLiteral(&vLiteral)
			if c.HasErr() {
				c.AddTokenErrorExpected("Literal")
				goto group1588Error
			}
			branch_out.Default = &vLiteral
		}

		out.Default = branch_out.Default
		break
	group1588Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctField1519Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

	// group ("(" Annotation ("," Annotation)* ")")?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "(" Annotation ("," Annotation)* ")"
		// literal "("
		if c.Lex.Peek().Value != "(" {
			c.SetTokenError("")
			goto group1624Error
		}
		c.Lex.Next()

		// capture Annotations from Annotation
		// strct Annotation
		{
			var vAnnotation Annotation
			c.parseAnnotation(&vAnnotation)
			if c.HasErr() {
				c.AddTokenErrorExpected("Annotation (\",\" Annotation)* \")\"")
				goto group1624Error
			}
			branch_out.Annotations = append(branch_out.Annotations, vAnnotation)
		}

		// group ("," Annotation)*
		for matches := 0; ; {
			branchCheckpoint := c.Lex.MakeCheckpoint()

			// sequence "," Annotation
			// literal ","
			if c.Lex.Peek().Value != "," {
				c.SetTokenError("")
				goto group1649Error
			}
			c.Lex.Next()

			// capture Annotations from Annotation
			// strct Annotation
			{
				var vAnnotation Annotation
				c.parseAnnotation(&vAnnotation)
				if c.HasErr() {
					c.AddTokenErrorExpected("Annotation")
					goto group1649Error
				}
				branch_out.Annotations = append(branch_out.Annotations, vAnnotation)
			}

			matches += 1
			if matches >= participle.MaxIterations {
				c.SetParseError("too many iterations of (\",\" Annotation)* (> 1000000)")
				goto group1624Error
			}
			continue
		group1649Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group1624Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			c.SuppressError()
			break
		}

		// literal ")"
		if c.Lex.Peek().Value != ")" {
			c.SetTokenError("\")\"")
			goto group1624Error
		}
		c.Lex.Next()

		out.Annotations = branch_out.Annotations
		break
	group1624Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctField1519Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

	// group ";"?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()

		// literal ";"
		if c.Lex.Peek().Value != ";" {
			c.SetTokenError("")
			goto group1706Error
		}
		c.Lex.Next()

		break
	group1706Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctField1519Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

strctField1519Error:
}

func (_ generatedParser) ParseAnnotation(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseAnnotation(out.(*Annotation))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseAnnotation(out *Annotation) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// sequence <ident> ("." <ident>)* ("=" Literal)?
	// capture Key from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -3 {
		c.SetTokenError("")
		goto strctAnnotation1736Error
	}
	c.AddToString(&out.Key, c.Lex.Peek().Value)
	c.Lex.Next()

	// group ("." <ident>)*
	for matches := 0; ; {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "." <ident>
		// capture Key from "."
		// literal "."
		if c.Lex.Peek().Value != "." {
			c.SetTokenError("")
			goto group1750Error
		}
		c.AddToString(&branch_out.Key, c.Lex.Peek().Value)
		c.Lex.Next()

		// capture Key from <ident>
		// reference <ident>
		if c.Lex.Peek().Type != -3 {
			c.SetTokenError("<ident>")
			goto group1750Error
		}
		c.AddToString(&branch_out.Key, c.Lex.Peek().Value)
		c.Lex.Next()

		matches += 1
		if matches >= participle.MaxIterations {
			c.SetParseError("too many iterations of (\".\" <ident>)* (> 1000000)")
			goto strctAnnotation1736Error
		}
		out.Key = branch_out.Key
		continue
	group1750Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctAnnotation1736Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

	// group ("=" Literal)?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "=" Literal
		// literal "="
		if c.Lex.Peek().Value != "=" {
			c.SetTokenError("")
			goto group1790Error
		}
		c.Lex.Next()

		// capture Value from Literal
		// strct Literal
		{
			var vLiteral Literal
			c.parseLiteral(&vLiteral)
			if c.HasErr() {
				c.AddTokenErrorExpected("Literal")
				goto group1790Error
			}
			branch_out.Value = &vLiteral
		}

		out.Value = branch_out.Value
		break
	group1790Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctAnnotation1736Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

strctAnnotation1736Error:
}

func (_ generatedParser) ParseType(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseType(out.(*Type))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseType(out *Type) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// sequence <ident> ("." <ident>)* ("<" Type ("," Type)? ">")?
	// capture Name from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -3 {
		c.SetTokenError("")
		goto strctType1835Error
	}
	c.AddToString(&out.Name, c.Lex.Peek().Value)
	c.Lex.Next()

	// group ("." <ident>)*
	for matches := 0; ; {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "." <ident>
		// capture Name from "."
		// literal "."
		if c.Lex.Peek().Value != "." {
			c.SetTokenError("")
			goto group1849Error
		}
		c.AddToString(&branch_out.Name, c.Lex.Peek().Value)
		c.Lex.Next()

		// capture Name from <ident>
		// reference <ident>
		if c.Lex.Peek().Type != -3 {
			c.SetTokenError("<ident>")
			goto group1849Error
		}
		c.AddToString(&branch_out.Name, c.Lex.Peek().Value)
		c.Lex.Next()

		matches += 1
		if matches >= participle.MaxIterations {
			c.SetParseError("too many iterations of (\".\" <ident>)* (> 1000000)")
			goto strctType1835Error
		}
		out.Name = branch_out.Name
		continue
	group1849Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctType1835Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

	// group ("<" Type ("," Type)? ">")?
	for {
		branchCheckpoint := c.Lex.MakeCheckpoint()
		branch_out := out

		// sequence "<" Type ("," Type)? ">"
		// literal "<"
		if c.Lex.Peek().Value != "<" {
			c.SetTokenError("")
			goto group1889Error
		}
		c.Lex.Next()

		// capture TypeOne from Type
		// strct Type
		{
			var vType Type
			c.parseType(&vType)
			if c.HasErr() {
				c.AddTokenErrorExpected("Type (\",\" Type)? \">\"")
				goto group1889Error
			}
			branch_out.TypeOne = &vType
		}

		// group ("," Type)?
		for {
			branchCheckpoint := c.Lex.MakeCheckpoint()

			// sequence "," Type
			// literal ","
			if c.Lex.Peek().Value != "," {
				c.SetTokenError("")
				goto group1914Error
			}
			c.Lex.Next()

			// capture TypeTwo from Type
			// strct Type
			{
				var vType Type
				c.parseType(&vType)
				if c.HasErr() {
					c.AddTokenErrorExpected("Type")
					goto group1914Error
				}
				branch_out.TypeTwo = &vType
			}

			break
		group1914Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto group1889Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			c.SuppressError()
			break
		}

		// literal ">"
		if c.Lex.Peek().Value != ">" {
			c.SetTokenError("\">\"")
			goto group1889Error
		}
		c.Lex.Next()

		out.TypeOne = branch_out.TypeOne
		out.TypeTwo = branch_out.TypeTwo
		break
	group1889Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctType1835Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		c.SuppressError()
		break
	}

strctType1835Error:
}

func (_ generatedParser) ParseArgument(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseArgument(out.(*Argument))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseArgument(out *Argument) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// sequence <number> ":" Type <ident>
	// capture ID from <number>
	// reference <number>
	if c.Lex.Peek().Type != -2 {
		c.SetTokenError("")
		goto strctArgument1976Error
	}
	c.AddToString(&out.ID, c.Lex.Peek().Value)
	c.Lex.Next()

	// literal ":"
	if c.Lex.Peek().Value != ":" {
		c.SetTokenError("\":\" Type <ident>")
		goto strctArgument1976Error
	}
	c.Lex.Next()

	// capture Type from Type
	// strct Type
	{
		var vType Type
		c.parseType(&vType)
		if c.HasErr() {
			c.AddTokenErrorExpected("Type <ident>")
			goto strctArgument1976Error
		}
		out.Type = vType
	}

	// capture Name from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -3 {
		c.SetTokenError("<ident>")
		goto strctArgument1976Error
	}
	c.AddToString(&out.Name, c.Lex.Peek().Value)
	c.Lex.Next()

strctArgument1976Error:
}

func (_ generatedParser) ParseThrow(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseThrow(out.(*Throw))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseThrow(out *Throw) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// sequence <number> ":" Type <ident>
	// capture ID from <number>
	// reference <number>
	if c.Lex.Peek().Type != -2 {
		c.SetTokenError("")
		goto strctThrow2027Error
	}
	c.AddToString(&out.ID, c.Lex.Peek().Value)
	c.Lex.Next()

	// literal ":"
	if c.Lex.Peek().Value != ":" {
		c.SetTokenError("\":\" Type <ident>")
		goto strctThrow2027Error
	}
	c.Lex.Next()

	// capture Type from Type
	// strct Type
	{
		var vType Type
		c.parseType(&vType)
		if c.HasErr() {
			c.AddTokenErrorExpected("Type <ident>")
			goto strctThrow2027Error
		}
		out.Type = vType
	}

	// capture Name from <ident>
	// reference <ident>
	if c.Lex.Peek().Type != -3 {
		c.SetTokenError("<ident>")
		goto strctThrow2027Error
	}
	c.AddToString(&out.Name, c.Lex.Peek().Value)
	c.Lex.Next()

strctThrow2027Error:
}

func (_ generatedParser) ParseLiteral(ctx participle.GeneratedParserContext, out interface{}) error {
	c := parserGeneratorContext{GeneratedParserContext: ctx}
	c.parseLiteral(out.(*Literal))
	return c.FinalError()
}

func (c *parserGeneratorContext) parseLiteral(out *Literal) {
	c.SuppressError()
	out.Pos = c.Lex.Peek().Pos

	// disjunction <string> | <number> | ("true" | "false") | (<ident> ("." <ident>)*) | ("-" Literal) | ("[" (Literal ","?)* "]") | ("{" (MapItem ","?)* "}")
	{
		branchCheckpoint := c.Lex.MakeCheckpoint()

		// capture Str from <string>
		// reference <string>
		if c.Lex.Peek().Type != -4 {
			c.SetTokenError("")
			goto disjunction2082Alt0Error
		}
		{
			var ptrValue1 string
			if out.Str != nil {
				ptrValue1 = *out.Str
			}
			c.AddToString(&ptrValue1, c.Lex.Peek().Value)
			out.Str = &ptrValue1
		}
		c.Lex.Next()

		goto disjunction2082Success
	disjunction2082Alt0Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// capture Number from <number>
		// reference <number>
		if c.Lex.Peek().Type != -2 {
			c.SetTokenError("")
			goto disjunction2082Alt1Error
		}
		{
			var ptrValue1 float64
			if out.Number != nil {
				ptrValue1 = *out.Number
			}
			if numValue, err := strconv.ParseFloat(c.Lex.Peek().Value, 64); err != nil {
				c.Lex.Next()
				c.SetCustomError("Literal.Number", err)
				goto strctLiteral2078Error
			} else {
				ptrValue1 = numValue
			}
			out.Number = &ptrValue1
		}
		c.Lex.Next()

		goto disjunction2082Success
	disjunction2082Alt1Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// capture Bool from ("true" | "false")
		{
			var bufBool string
			// disjunction "true" | "false"
			switch c.Lex.Peek().Value {
			case "true", "false":
				bufBool = c.Lex.Peek().Value
				c.Lex.Next()
			default:
				c.SetTokenError("")
				goto disjunction2082Alt2Error
			}

			{
				var ptrValue1 string
				if out.Bool != nil {
					ptrValue1 = *out.Bool
				}
				c.AddToString(&ptrValue1, bufBool)
				out.Bool = &ptrValue1
			}
		}

		goto disjunction2082Success
	disjunction2082Alt2Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// sequence <ident> ("." <ident>)*
		// capture Reference from <ident>
		// reference <ident>
		if c.Lex.Peek().Type != -3 {
			c.SetTokenError("")
			goto disjunction2082Alt3Error
		}
		{
			var ptrValue1 string
			if out.Reference != nil {
				ptrValue1 = *out.Reference
			}
			c.AddToString(&ptrValue1, c.Lex.Peek().Value)
			out.Reference = &ptrValue1
		}
		c.Lex.Next()

		// group ("." <ident>)*
		for matches := 0; ; {
			branchCheckpoint := c.Lex.MakeCheckpoint()
			branch_out := out

			// sequence "." <ident>
			// capture Reference from "."
			// literal "."
			if c.Lex.Peek().Value != "." {
				c.SetTokenError("")
				goto group2185Error
			}
			{
				var ptrValue1 string
				if branch_out.Reference != nil {
					ptrValue1 = *branch_out.Reference
				}
				c.AddToString(&ptrValue1, c.Lex.Peek().Value)
				branch_out.Reference = &ptrValue1
			}
			c.Lex.Next()

			// capture Reference from <ident>
			// reference <ident>
			if c.Lex.Peek().Type != -3 {
				c.SetTokenError("<ident>")
				goto group2185Error
			}
			{
				var ptrValue1 string
				if branch_out.Reference != nil {
					ptrValue1 = *branch_out.Reference
				}
				c.AddToString(&ptrValue1, c.Lex.Peek().Value)
				branch_out.Reference = &ptrValue1
			}
			c.Lex.Next()

			matches += 1
			if matches >= participle.MaxIterations {
				c.SetParseError("too many iterations of (\".\" <ident>)* (> 1000000)")
				goto disjunction2082Alt3Error
			}
			out.Reference = branch_out.Reference
			continue
		group2185Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto disjunction2082Alt3Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			c.SuppressError()
			break
		}

		goto disjunction2082Success
	disjunction2082Alt3Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// sequence "-" Literal
		// literal "-"
		if c.Lex.Peek().Value != "-" {
			c.SetTokenError("")
			goto disjunction2082Alt4Error
		}
		c.Lex.Next()

		// capture Minus from Literal
		// strct Literal
		{
			var vLiteral Literal
			c.parseLiteral(&vLiteral)
			if c.HasErr() {
				c.AddTokenErrorExpected("Literal")
				goto disjunction2082Alt4Error
			}
			out.Minus = &vLiteral
		}

		goto disjunction2082Success
	disjunction2082Alt4Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// sequence "[" (Literal ","?)* "]"
		// literal "["
		if c.Lex.Peek().Value != "[" {
			c.SetTokenError("")
			goto disjunction2082Alt5Error
		}
		c.Lex.Next()

		// group (Literal ","?)*
		for matches := 0; ; {
			branchCheckpoint := c.Lex.MakeCheckpoint()
			branch_out := out

			// sequence Literal ","?
			// capture List from Literal
			// strct Literal
			{
				var vLiteral Literal
				c.parseLiteral(&vLiteral)
				if c.HasErr() {
					goto group2281Error
				}
				branch_out.List = append(branch_out.List, vLiteral)
			}

			// group ","?
			for {
				branchCheckpoint := c.Lex.MakeCheckpoint()

				// literal ","
				if c.Lex.Peek().Value != "," {
					c.SetTokenError("")
					goto group2298Error
				}
				c.Lex.Next()

				break
			group2298Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group2281Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)
				c.SuppressError()
				break
			}

			matches += 1
			if matches >= participle.MaxIterations {
				c.SetParseError("too many iterations of (Literal \",\"?)* (> 1000000)")
				goto disjunction2082Alt5Error
			}
			out.List = branch_out.List
			continue
		group2281Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto disjunction2082Alt5Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			c.SuppressError()
			break
		}

		// literal "]"
		if c.Lex.Peek().Value != "]" {
			c.SetTokenError("\"]\"")
			goto disjunction2082Alt5Error
		}
		c.Lex.Next()

		goto disjunction2082Success
	disjunction2082Alt5Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)

		// sequence "{" (MapItem ","?)* "}"
		// literal "{"
		if c.Lex.Peek().Value != "{" {
			c.SetTokenError("")
			goto disjunction2082Alt6Error
		}
		c.Lex.Next()

		// group (MapItem ","?)*
		for matches := 0; ; {
			branchCheckpoint := c.Lex.MakeCheckpoint()
			branch_out := out

			// sequence MapItem ","?
			// capture Map from MapItem
			// strct MapItem
			{
				var vMapItem MapItem
				vMapItem.Pos = c.Lex.Peek().Pos

				// sequence Literal ":" Literal
				// capture Key from Literal
				// strct Literal
				{
					var vLiteral Literal
					c.parseLiteral(&vLiteral)
					if c.HasErr() {
						goto group2357Error
					}
					vMapItem.Key = &vLiteral
				}

				// literal ":"
				if c.Lex.Peek().Value != ":" {
					c.SetTokenError("\":\" Literal")
					goto group2357Error
				}
				c.Lex.Next()

				// capture Value from Literal
				// strct Literal
				{
					var vLiteral Literal
					c.parseLiteral(&vLiteral)
					if c.HasErr() {
						c.AddTokenErrorExpected("Literal")
						goto group2357Error
					}
					vMapItem.Value = &vLiteral
				}

				branch_out.Map = append(branch_out.Map, vMapItem)
			}

			// group ","?
			for {
				branchCheckpoint := c.Lex.MakeCheckpoint()

				// literal ","
				if c.Lex.Peek().Value != "," {
					c.SetTokenError("")
					goto group2403Error
				}
				c.Lex.Next()

				break
			group2403Error:
				if c.AboveLookahead(branchCheckpoint) {
					goto group2357Error
				}
				c.Lex.LoadCheckpoint(branchCheckpoint)
				c.SuppressError()
				break
			}

			matches += 1
			if matches >= participle.MaxIterations {
				c.SetParseError("too many iterations of (MapItem \",\"?)* (> 1000000)")
				goto disjunction2082Alt6Error
			}
			out.Map = branch_out.Map
			continue
		group2357Error:
			if c.AboveLookahead(branchCheckpoint) {
				goto disjunction2082Alt6Error
			}
			c.Lex.LoadCheckpoint(branchCheckpoint)
			c.SuppressError()
			break
		}

		// literal "}"
		if c.Lex.Peek().Value != "}" {
			c.SetTokenError("\"}\"")
			goto disjunction2082Alt6Error
		}
		c.Lex.Next()

		goto disjunction2082Success
	disjunction2082Alt6Error:
		if c.AboveLookahead(branchCheckpoint) {
			goto strctLiteral2078Error
		}
		c.Lex.LoadCheckpoint(branchCheckpoint)
		goto strctLiteral2078Error
	}
disjunction2082Success:
	c.SuppressError()

strctLiteral2078Error:
}

// GeneratedParsers exposes non-inlined methods for sub-parsing.
func (g generatedParser) GeneratedParsers() participle.GeneratedParserFns {
	// The entrypoint to the generated code. Basically a static method. Shadows embedded method.
	return participle.GeneratedParserFns{
		reflect.TypeOf((*Thrift)(nil)): g.ParseThrift,
		reflect.TypeOf((*Field)(nil)): g.ParseField,
		reflect.TypeOf((*Annotation)(nil)): g.ParseAnnotation,
		reflect.TypeOf((*Type)(nil)): g.ParseType,
		reflect.TypeOf((*Argument)(nil)): g.ParseArgument,
		reflect.TypeOf((*Throw)(nil)): g.ParseThrow,
		reflect.TypeOf((*Literal)(nil)): g.ParseLiteral,
	}
}
